Termite is a generic distributed compilation system.

The master distributes the compilation to workers.  Workers run
arbitrary binaries chrooted in a FUSE mirror of the master's file
system, and then ship the results back to the master.


CAVEATS

Work in progress.


COMPILE

Use the following recipe

  git clone git://github.com/hanwen/go-fuse.git
  git clone git://github.com/hanwen/termite.git
  cd go-fuse && sh all.bash
  cd termite && sh all.bash

I do not goinstall go-fuse, since I develop go-fuse in tandem with
termite, but with some tweaks to the Makefile it should work.


OVERVIEW

There are 4 binaries:

* Coordinator: a simple server that administers a list of live
workers.  Workers periodically contact the coordinator.

* Worker: should run as root, and typically runs on multiple machines.

* Master: the daemon that runs on the machine.  It contacts the
coordinator to get a list of workers, and reserves job slots on the
workers.  Run it in the root of the writable directory for the
compile.  It creates a .termite-socket that the wrapper below uses.

* Wrapper: should be symlinked to using the name of the tool you want
to wrap (eg. gcc).  Put all the symlinks in one directory, and add
that directory to the PATH variable.


RUNNING

  dd if=/dev/random of=secret.txt bs=1 count=20 && chmod 0600 secret.txt
  ${TERMITE_DIR}/bin/coordinator/coordinator &
  sudo ${TERMITE_DIR}/bin/worker/worker -jobs 4 \
    -chroot ${TERMITE_DIR}/bin/chroot/chroot &
  cd ${PROJECT}
  ${TERMITE_DIR}/bin/master/master -jobs 4 &
  ln -s ${TERMITE_DIR}/bin/wrapper/wrapper gcc
  ./gcc


SECURITY

* The worker runs binaries as user 'nobody' in a chroot of a FUSE file
  system.  It needs root permission for the following actions:

  - mount a FUSE fs as allow_other
  - chroot to FUSE fs
  - change uid to user 'nobody'

* Worker and master use plaintext TCP/IP, and use a shared secret with
  HMAC-SHA1 to authenticate the connection.  See
  https://github.com/hanwen/termite/blob/master/termite/connection.go
  for details.

  If this connection scheme gets broken,

  - a malicious user may request all files from the master that the
    UID running the master has access to.

  - a malicious user may try to run a binary on the worker that tries
    to break out of chroot.

* Wrapper and master run as the same user and use IPC unix domain
  sockets to communicate.  The socket mode is 0700.


TODO

* Master dropping mirrorConnection after X seconds of idle.

* Caching path => md5 mapping in the master.

* More sophisticated exclusion for exporting file systems.

* Security review for the connection scheme.

* Write a wrapper for SHELL, so we have more flexibility for wrapping
  binaries.
